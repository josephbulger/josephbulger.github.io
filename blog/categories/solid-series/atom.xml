<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Solid Series | Joseph Bulger]]></title>
  <link href="http://josephbulger.com/blog/categories/solid-series/atom.xml" rel="self"/>
  <link href="http://josephbulger.com/"/>
  <updated>2014-08-24T20:46:43-04:00</updated>
  <id>http://josephbulger.com/</id>
  <author>
    <name><![CDATA[Joseph Bulger]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SOLID Principles: Single Responsibility Principle]]></title>
    <link href="http://josephbulger.com/blog/2011/09/16/solid-principles-single-responsibility-principle/"/>
    <updated>2011-09-16T14:00:33-04:00</updated>
    <id>http://josephbulger.com/blog/2011/09/16/solid-principles-single-responsibility-principle</id>
    <content type="html"><![CDATA[<p>I saved <a href="http://en.wikipedia.org/wiki/Single_responsibility_principle">Single Responsibility Principle </a>(SRP) for last. I think it&rsquo;s the most important principle to understand and to utilize correctly. I would even go so far as to say it&rsquo;s the most important principle to follow.</p>

<!-- more -->


<p>So why is SRP so important? I guess it&rsquo;s all in it&rsquo;s definition. A class or file should only have one reason to change. If it has more than one reason to change, then your code will become brittle and difficult to maintain. The problem with SRP is how difficult it is to follow. SRP feels a lot more like an art than a science at times. You get into situations where you&rsquo;re not sure whether or not a class is only doing one thing, and if you need to further abstract away code into separate classes.</p>

<p>As a simple example, let&rsquo;s say you have a Car that needs to be able to start it&rsquo;s Engine</p>

<p>{% gist 1208417 BadCar.cs %}</p>

<p>This Car knows <em><strong>way</strong></em> too much about it&rsquo;s Engine. If the Engine&rsquo;s starting sequence ever needs to be changed, you have to actually go into the Car class to change it! That just doesn&rsquo;t make any sense. What we should be doing instead is abstracting away that functionality inside the Engine class and allowing the Car to simply start the Engine when it needs to.</p>

<p>{% gist 1208417 Engine.cs %}</p>

<p>This Engine prevents other classes from using it improperly. Part of learning how to effectively use SRP is to identify when you&rsquo;re exposing too much of a class. In the previous Engine the Car was calling each function inside the Engine. This better designed Engine hides this functionality from outsiders, so the Car now has no choice but to use only the start method.</p>

<p>The Car now has to look something like this</p>

<p>{% gist 1208417 GoodCar.cs %}</p>

<p>This is a class structure that utilizes SRP.</p>

<p>Want more info? <a href="http://www.dimecasts.net/Content/WatchEpisode/88">Check out this dime cast</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SOLID Principles: Dependency Inversion Principle]]></title>
    <link href="http://josephbulger.com/blog/2011/09/14/solid-principles-dependency-inversion-principle/"/>
    <updated>2011-09-14T14:00:18-04:00</updated>
    <id>http://josephbulger.com/blog/2011/09/14/solid-principles-dependency-inversion-principle</id>
    <content type="html"><![CDATA[<p><a href="http://en.wikipedia.org/wiki/Dependency_inversion_principle">Dependency Inversion Principle</a> has a dramatic effect on your code base. It has the potential to decouple your code in ways that you never would have thought possible before. Using a good IoC container can make all the difference as well.</p>

<!-- more -->


<p>The best way to explain this principle would probably be an example.
Let&rsquo;s say you have a car like this</p>

<p>{% gist 1208366 CoupledCar.cs %}</p>

<p>Notice the engine that belongs to the car. First of all, the car is actually creating the engine. This means that the car is tightly coupled to the engine it&rsquo;s creating. Secondly, this creates a concrete coupling on the car to a specific kind of engine, the FourCylinderEngine.</p>

<p>A better solution would be to use Dependency Inversion. You should depend on an interface instead of a concrete class. Back in our example, our FoudCyclinderEngine looks like this</p>

<p>{% gist 1208366 FourCylinderEngine.cs %}</p>

<p>Notice how it implements Engine. That&rsquo;s the interface our Car should be using. There&rsquo;s one additional problem, though. Right now the Car is creating it&rsquo;s Engine, but you can&rsquo;t instantiate an interface, so what do you do? That&rsquo;s the key to Dependency Inversion. You&rsquo;re saying,</p>

<blockquote><p>a Car does not depend on knowing about how to create an Engine</p></blockquote>

<p>It just <em>uses</em> it. So the new Car class looks like this</p>

<p>{% gist 1208366 DecoupledCar.cs %}</p>

<p>So how does the engine get created? Obviously something is passing in the engine to the Car, but what? You need a new class. Maybe a CarManufacturer or something, which is responsible for manufacturing cars. Part of that responsibility would be putting an engine in a car.</p>

<p>Want more info? <a href="http://www.dimecasts.net/Content/WatchEpisode/96">Check out this dime cast</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SOLID Principles: Interface Segregation Principle]]></title>
    <link href="http://josephbulger.com/blog/2011/09/12/solid-principles-interface-segregation-principle/"/>
    <updated>2011-09-12T08:00:26-04:00</updated>
    <id>http://josephbulger.com/blog/2011/09/12/solid-principles-interface-segregation-principle</id>
    <content type="html"><![CDATA[<p>Interface Segregation Principle (ISP), focuses on the idea that it&rsquo;s better to have many small specific interfaces that define one concept, then to have one big contract that encompasses many concepts in one.</p>

<!-- more -->


<p>I think a prime example of an interface that violates this principle would be <a href="http://msdn.microsoft.com/en-us/library/f1kyba5e.aspx">MembershipProvider </a>class which is commonly used in ASP.NET applications. Granted, this isn&rsquo;t technically an interface (it&rsquo;s actually an abstract class), but it demonstrates the principle perfectly. If you&rsquo;ve ever tried to make your own custom membership provider, and you&rsquo;ve had to implement this beast, you already know the pain involved. There are a ridiculous number of methods involved with this class. There are so many, actually, that the best practice inside many .NET circles has been to simply throw a NotImplementedException for any methods you don&rsquo;t want to spend the time implementing.</p>

<p>The solution would be to actually break up this abstract class into many smaller classes, so the developer could extend the parts that needs to be customized, and leave the rest alone.</p>

<p>Want more info? <a href="http://www.dimecasts.net/Content/WatchEpisode/94">Check out this dime cast</a>.</p>
]]></content>
  </entry>
  
</feed>
