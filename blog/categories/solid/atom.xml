<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Solid | Joseph Bulger]]></title>
  <link href="http://josephbulger.com/blog/categories/solid/atom.xml" rel="self"/>
  <link href="http://josephbulger.com/"/>
  <updated>2014-03-03T22:51:34-05:00</updated>
  <id>http://josephbulger.com/</id>
  <author>
    <name><![CDATA[Joseph Bulger]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[When Is It Ok to Violate the D in SOLID?]]></title>
    <link href="http://josephbulger.com/blog/2014/03/03/when-is-it-ok-to-violate-the-d-in-solid/"/>
    <updated>2014-03-03T21:37:04-05:00</updated>
    <id>http://josephbulger.com/blog/2014/03/03/when-is-it-ok-to-violate-the-d-in-solid</id>
    <content type="html"><![CDATA[<p>I&rsquo;m about to begin my annual re-read of <a href="http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882">Clean Code</a>, but before I start this year I thought it would be idea to touch on a subject that I haven&rsquo;t actually seen a lot of discussion on.</p>

<p>That issue begins with a premise: we all violate SOLID principles in our code. We <em>have</em> to. You can&rsquo;t write any non-trivial project without violating at least one of the principles. Most of the time you&rsquo;ll find yourself choosing one over another, and that is where I thought an intersting topic of conversation could be had.</p>

<p>When is it ok to violate SOLID principles? For this post, specifically the <a href="http://en.wikipedia.org/wiki/Dependency_inversion_principle">D</a></p>

<!-- more -->


<p>One other thing before we really start diving in. This topic is going to be highly subjective, by it&rsquo;s nature I presume. I&rsquo;m speaking of my current experience, which admittedly is not as extensive as a lot of software craftsman out there. I do, however, think I have enough experience to at least provide some insight into the discussion. If nothing else, I&rsquo;ll be able to read this in 6 months and laugh at myself for being so dumb.</p>

<p>Let&rsquo;s get one thing clear right off the bat. It&rsquo;s not the Dependency <strong>Injection</strong> Principle, it&rsquo;s the Dependency <strong>Inversion</strong> Principle (DIP for short). Meaning, you are inverting the dependencies so that high level policy does not depend on low level details. I&rsquo;m going to assume you know what that entails.</p>

<p>So when is ok to violate this principle?</p>

<p>My experience so far has been this. When I am building software, I specifically pay very close attention to one thing in regards to DIP: my application boundaries. Across boundaries, I make it a point to never violate DIP. If you don&rsquo;t know what I&rsquo;m referring to when I talk about application boundaries, then you need to read up on Component Based Design. In general, though, I&rsquo;m talking about breaking up your application into Components that are specific to a type of user. It should be completely based on a business vertical. Once you have all your Components identified, then you can start drawing boundaries around them. This is where things get interesting. The general rule is very simple: do not have your dependencies go both ways across boundaries.</p>

<p>For example, let&rsquo;s say you have a Component called Scheduling, and another component called Packaging. These two Components interact with each other, so there is a boundary there. The question is, what direction should the dependency go? The answer of course, using DIP, is to figure out which Component is the higher level policy, and which is a detail. In this example, Scheduling is the higher level policy, and Packaging is just a detail of that overall workflow (albeit for a different user base). This means that the dependency arrows goes across the Scheduling / Packaging boundary pointing from Packaging over to Scheduling.</p>

<p>So on my projects, it is never ok to violate DIP when dealing with Component boundaries. However, inside a Component it&rsquo;s not as clear cut. For example, inside the Scheduling Component there may be a workflow that exists only there, and it doesn&rsquo;t venture outside of the component. No other Component ever sees this workflow, no one even knows it exists. On top of that, the code footprint for that workflow is small. In situations such as this, DIP can and will be violated in favor of adhering more strictly to other SOLID principles.</p>

<p>I want to also be clear about one thing here. Notice how I said that DIP can be violated <em>in favor of other principles</em>. I do not advocate violating principles out of sheer laziness. That is not the point. The point is, as a craftsman, there will be times where you have to choose certain principles over others. And so, what I&rsquo;m really getting at here is, inside a Component boundary, it&rsquo;s ok to violate DIP in favor of say, for example, SRP. In that case SRP may take a higher precedent than DIP. That would not be the case if you were crossing Component boundaries, but since you&rsquo;re not, then other principles can take higher priority.</p>

<p>This brings up an interesting question, though. Is there a SOLID principle that you should never, under any circumstances, violate? I&rsquo;ll leave that one for another time.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mental Floss: Days for a Week]]></title>
    <link href="http://josephbulger.com/blog/2011/10/20/mental-floss-days-for-a-week/"/>
    <updated>2011-10-20T04:00:50-04:00</updated>
    <id>http://josephbulger.com/blog/2011/10/20/mental-floss-days-for-a-week</id>
    <content type="html"><![CDATA[<p>So as I build the week up, I&rsquo;m adding Days onto it, but what do they look like?</p>

<!-- more -->


<p>A Day is pretty simple. It has the DateTime that says what actual day it belongs to. It also has a list of Events that belong to it. A Day can also indicate whether or not it&rsquo;s available for reading, or if it has events. This is important because if a day is available, then the UI needs to let the user select that Day, and if it has events, then the day should show those events in the UI.</p>

<p>``` c#</p>

<pre><code>public class Day
{
    public DateTime Date { get; set; }

    private IList&lt;Event&gt; Events { get; set; }

    public Day()
    {
        Events = new List&lt;Event&gt;();
    }

    public bool HasEvents()
    {
        return Events.Count &gt; 0;
    }

    public void AddEvent(Event eventForDay)
    {
        Events.Add(eventForDay);
    }

    public IList&lt;Event&gt; GetEvents()
    {
        return Events;
    }

    public string GetReadingAvailability()
    {
        return IsAvailable() ? "date_is_available" : 
          HasEvents() ? "date_has_event" : "");
    }

    private bool IsAvailable()
    {
        return !HasEvents() &amp;&amp; IsDayAvailableForReading();
    }

    private bool IsDayAvailableForReading()
    {
        return IsDayAvailableForReading(Date);
    }

    public static bool IsDayAvailableForReading(DateTime dateTime)
    {
        return new AvailabilityChecker()
          .IsDayAvailableForReading(dateTime);
    }

    public string GetReadableValue()
    {
        return Date.ToString("MMMM dd, yyyy");
    }
}
</code></pre>

<p>```</p>

<p>This concludes the implementation of all the pieces necessary to build the ViewModel. The View itself could be built on any technology stack to show UI appropriate to the rules we outlined so far, which is the ultimate goal of having our ViewModel separated from the View itself.</p>

<p>This does <strong>not</strong>, however, tell us what our business rules are, or how their implemented, which is the next part of the series: the Model.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mental Floss: Weeks on the Calendar]]></title>
    <link href="http://josephbulger.com/blog/2011/10/19/mental-floss-weeks-on-the-calendar/"/>
    <updated>2011-10-19T04:00:48-04:00</updated>
    <id>http://josephbulger.com/blog/2011/10/19/mental-floss-weeks-on-the-calendar</id>
    <content type="html"><![CDATA[<p>Now we&rsquo;ve gone through how the <a href="/?p=817">month is modeled</a>, we need to see how weeks are being built.</p>

<!-- more -->


<p>When you first look at the month implementation, you might think that adding days to weeks is a simple matter of adding DateTime&rsquo;s, but what&rsquo;s happening behind the scenes is just a little bit more complicated. Why? Well, we need to track what events belong to what days, so in order to do that we can&rsquo;t just use a simple DateTime, we need something just a little bit more complicated.</p>

<p>My Week looks like this:</p>

<p><div><script src='https://gist.github.com/1291245.js?file=Week.cs'></script>
<noscript><pre><code>﻿public class Week
{
    public Week()
    {
        Days = new List&lt;Day&gt;();
    }

    protected IList&lt;Day&gt; Days { get; set; }

    public IEnumerable&lt;Day&gt; GetDays()
    {
        return Days;
    }

    public void Add(DateTime day)
    {
        if (!Days.Where(x =&gt; x.Date == day.Date).Any())
            Days.Add(new Day { Date = day });
    }

    public bool IsMissingDays()
    {
        return Days.OrderBy(x =&gt; x.Date)
          .First().Date.DayOfWeek != Calendar.GetStartDay();
    }

    public bool IsMissingTrailingDays()
    {
        return Days.OrderBy(x =&gt; x.Date)
          .First().Date.DayOfWeek != Calendar.GetLastDay();
    }

    public int GetMissingNumberOfDays()
    {
        var missingDays = 0;

        var day = Days.OrderBy(x =&gt; x.Date).First().Date;
        
        do
        {
            day = day.AddDays(-1);
            missingDays++;
        } while (day.DayOfWeek != Calendar.GetStartDay());

        return missingDays;
    }

    public int GetMissingNumberOfTrailingDays()
    {
        var missingDays = 0;

        var day = Days.OrderBy(x =&gt; x.Date).Last().Date;

        do
        {
            day = day.AddDays(1);
            missingDays++;
        } while (day.DayOfWeek != Calendar.GetLastDay());

        return missingDays;
    }
}</code></pre></noscript></div>
</p>

<p>When adding days to the week, I accept a DateTime and then build a list of Days into the Week. Later on, the calendar will add Events to these Days.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mental Floss: The Month on the Calendar]]></title>
    <link href="http://josephbulger.com/blog/2011/10/17/mental-floss-the-month-on-the-calendar/"/>
    <updated>2011-10-17T04:00:02-04:00</updated>
    <id>http://josephbulger.com/blog/2011/10/17/mental-floss-the-month-on-the-calendar</id>
    <content type="html"><![CDATA[<p>So we&rsquo;ve seen what the Calendar looks like, and how it&rsquo;s building it&rsquo;s Months, but what goes into building a Month?</p>

<!-- more -->


<p>So building a Month is all about one thing: building it&rsquo;s weeks. The only other thing I need from a month is the ability to get it&rsquo;s name (i.e. January, February, etc.). My implementation of this looks something like this:</p>

<p><div><script src='https://gist.github.com/1291245.js?file=Month.cs'></script>
<noscript><pre><code>﻿public class Month
{
  private DateTime FirstDayOfMonth { get; set; }
  
  private IList&lt;Week&gt; Weeks { get; set; }

  public Month(int monthValue)
  {
      FirstDayOfMonth = new DateTime(DateTime.Now.Year, monthValue, 1);
      
      Weeks = new List&lt;Week&gt;();

      BuildMonth();
  }

  private void BuildMonth()
  {
      var startDay = Calendar.GetStartDay();

      var week = new Week();

      var day = FirstDayOfMonth;
      
      do
      {
          if (WeekHasEnded(day, startDay) &amp;&amp; WeekIsNotEmpty(week))
          {
              Weeks.Add(week);
              week = new Week();
          }

          week.Add(day);
          
          day = GetNextDay(day);

      } while (day.Month == FirstDayOfMonth.Month);

      Weeks.Add(week);
  }

  private bool WeekIsNotEmpty(Week week)
  {
      return week.GetDays().Count() &gt; 0;
  }

  private bool WeekHasEnded(DateTime day, DayOfWeek startDay)
  {
      return day.DayOfWeek == startDay;
  }

  private DateTime GetNextDay(DateTime day)
  {
      return day.AddDays(1);
  }

  public DayOfWeek GetFirstDayOfMonth()
  {
      return FirstDayOfMonth.DayOfWeek;
  }

  public IList&lt;Week&gt; GetWeeks()
  {
      return Weeks;
  }
  
  public string GetMonthName()
  {
      return string.Format(&quot;{0:MMMM}&quot;, FirstDayOfMonth);
  }
}</code></pre></noscript></div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mental Floss: The Calendar ViewModel]]></title>
    <link href="http://josephbulger.com/blog/2011/10/16/mental-floss-the-calendar-viewmodel/"/>
    <updated>2011-10-16T12:46:08-04:00</updated>
    <id>http://josephbulger.com/blog/2011/10/16/mental-floss-the-calendar-viewmodel</id>
    <content type="html"><![CDATA[<p>So my ViewModel basically starts with the idea of a Calendar and it&rsquo;s Events. So what did I end up making that look like? Let&rsquo;s disregard the markup for now, because how it looks isn&rsquo;t really what we&rsquo;re talking about here. What we&rsquo;re talking about is how the Calendar and it&rsquo;s Events are <em><strong>modeled</strong></em>.</p>

<!-- more -->


<p>So my Calendar looks like this:</p>

<p>``` c#</p>

<pre><code>public class Calendar
{
  public Calendar()
  {
      Months = new Dictionary&lt;int, Month&gt; 
        ;
  }

  protected IDictionary&lt;int, Month&gt; Months { get; set; }

  public Month GetCurrentMonth()
  {
      return GetMonth(DateTime.Today.Month);
  }

  public Month GetNextMonth()
  {
      return GetMonth(DateTime.Today.Month + 1);
  }

  public Month GetMonth(string month)
  {
      return GetMonth(
        DateTime.ParseExact(
          month, "MMMM", CultureInfo.CurrentCulture)
        .Month);
  }

  public Month GetMonth(int monthValue)
  {
      if (!Months.ContainsKey(monthValue))
          Months.Add(monthValue, new Month(monthValue));

      return Months[monthValue];
  }

  public static DayOfWeek GetStartDay()
  {
      return DayOfWeek.Monday;
  }

  public static DayOfWeek GetLastDay()
  {
      return DayOfWeek.Sunday;
  }

  public void IncludeEvents(IList&lt;Event&gt; events)
  {
      foreach (var @event in events)
      {
          IncludeEvent(@event);
      }
  }

  private void IncludeEvent(Event eventToInclude)
  {
      var allDaysQuery = from week in GetMonth(
          eventToInclude.Day.Month)
            .GetWeeks()
        from day in week.GetDays()
        select day;

      var filteredDays = from day in allDaysQuery
                         where day.Date == eventToInclude.Day.Date
                         select day;

      var dayToAddEventTo = filteredDays.First();

      dayToAddEventTo.AddEvent(eventToInclude);
  }
}
</code></pre>

<p>```</p>

<p>The Calendar is really only concerned with one thing: showing events that belong to it. In order to accomplish this goal, the Calendar must be able to include events into the months on the Calendar.</p>

<p>In order to do this, the Calendar has to be able to build months, and then include the events into the days of those months. All of this logic takes place in the IncludeEvent method, which utilizes quite a few other classes to accomplish this.</p>

<p>In the next post, we&rsquo;ll take a look at the other classes we used in the ViewModel to accommodate our Calendar</p>
]]></content>
  </entry>
  
</feed>
