<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: linkedIn | Joseph Bulger]]></title>
  <link href="http://josephbulger.com/blog/categories/linkedin/atom.xml" rel="self"/>
  <link href="http://josephbulger.com/"/>
  <updated>2014-02-23T14:56:17-05:00</updated>
  <id>http://josephbulger.com/</id>
  <author>
    <name><![CDATA[Joseph Bulger]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Creating an PagedList<T> That Uses AJAX]]></title>
    <link href="http://josephbulger.com/blog/2010/04/14/creating-an-pagedlistt-that-uses-ajax/"/>
    <updated>2010-04-14T05:05:58-04:00</updated>
    <id>http://josephbulger.com/blog/2010/04/14/creating-an-pagedlistt-that-uses-ajax</id>
    <content type="html"><![CDATA[<p>I’ve been using this PagedList functionality that i found from a <a href="http://blog.wekeroad.com/2007/12/10/aspnet-mvc-pagedlistt/">blog article Rob Conery</a> put up, and <a href="http://code-inside.de/blog-in/2008/04/08/aspnet-mvc-pagination-view-user-control/">a control I found by Robert Muehsig</a> which I’ve really enjoyed using so far.</p>

<p>One of the things that was missing from the functional set that I ended up needing was the ability to page the list, but through issuing AJAX requests instead of the typical post back.</p>

<p>So I went off and extended the existing model to support AJAX requests, and thought I would share it in case anyone else needed to do the same thing.<!-- more --></p>

<p>I guess the best place to start would be the use case.  So to start I created a control that encapsulates the Paging UI layout and calls I need.  The use of the original control looks like this:</p>

<p>``` c#</p>

<p>Html.RenderPartial(&ldquo;AjaxPagination&rdquo;,</p>

<pre><code>new AjaxPaginationViewData
    {
        PageIndex = Model.PageIndex,
        Action = "CondoPage",
        Controller = "Home",
        AjaxOptions =
            new AjaxOptions { 
                UpdateTargetId = "updatedContent" },
        TotalCount = Model.TotalCount,
        PageSize = Model.PageSize,
        NumberOfPagesToEachSide = 2
    }
</code></pre>

<p>);</p>

<p>```</p>

<p>The new AJAX functionality is called similarly:</p>

<p>``` c#</p>

<p>&lt;% using (Ajax.BeginForm(&ldquo;SomePage&rdquo;,</p>

<pre><code>    "SomeController",
    new AjaxOptions { UpdateTargetId = "updatedContent" })) { %&gt;

    &lt;% Html.RenderPartial("AjaxPagination",
        new AjaxPaginationViewData {
                PageIndex = Model.PageIndex,
                Action = "SomeAction",
                Controller = "SomeController",
                AjaxOptions = new AjaxOptions
                    { UpdateTargetId = "updatedContent" },
                TotalCount = Model.TotalCount,
                PageSize = Model.PageSize,
                NumberOfPagesToEachSide = 2
    });%&gt;
</code></pre>

<p>&lt;% } %></p>

<p>```</p>

<p>A couple things to note. You’ll notice that the AJAX control is rendered inside a Ajax.BeginForm. This is because I’m using the Microsoft.Ajax way of making AJAX calls.  This could also be done using jQuery or something else that can process AJAX calls. I just went this way because the scripts are already included in asp.net mvc app when you first create the project.  The result of the AJAX call will be a partial view, and we’ll need to put that somewhere.  That’s where the UpdatedTargetId comes into play. Other things we include in the AJAX control that are not in the original are the Action and the Controller, and some AjaxOptions. PageActionLink doesn’t work with the AJAX control, because we’ll be using Ajax.ActionLink to build the link, which is why I broke it up into Action, and Controller. For the AjaxOptions, we need those to specify the target of the call.</p>

<p>So now that’s been explained, let’s look at the controls themselves.  Here’s a comparison of the original control and the ajax control.</p>

<p>The original is one this way:</p>

<p>``` c#</p>

<p>&lt;% if (Model.HasPreviousPage) { %></p>

<pre><code>&lt;a href="&lt;%=Model.PageActionLink.Replace("%7Bpage%7D", (Model.PageIndex - 1).ToString())%&gt;"&gt;Previous&lt;/a&gt;
</code></pre>

<p>&lt;% } %></p>

<p>&lt;% if (Model.GetFirstPageToLink() != 1) { %>&hellip;&lt;% } %></p>

<p>&lt;%for (var page = Model.GetFirstPageToLink(); page &lt;= Model.GetLastPageToLink(); page++) {</p>

<pre><code>if (page == Model.PageIndex) { %&gt;
    &lt;%=page.ToString()%&gt;
</code></pre>

<p>&lt;% } else { %></p>

<pre><code>&lt;a href="&lt;%=Model.PageActionLink.Replace("%7Bpage%7D", page.ToString())%&gt;"&gt;&lt;%=page.ToString()%&gt;&lt;/a&gt;
</code></pre>

<p>&lt;% }</p>

<pre><code>if (page != Model.GetLastPageToLink()) { %&gt;|&lt;% } } %&gt;
</code></pre>

<p>&lt;% if (Model.GetLastPageToLink() != Model.PageCount) { %>&hellip;&lt;% } %></p>

<p>&lt;% if (Model.HasNextPage) { %></p>

<pre><code>&lt;a href="&lt;%=Model.PageActionLink.Replace("%7Bpage%7D", (Model.PageIndex + 1).ToString())%&gt;"&gt;Next&lt;/a&gt;
</code></pre>

<p>&lt;% } %></p>

<p>```</p>

<p>And the AJAX control is done this way:</p>

<p>``` c#</p>

<p>&lt;% if (Model.HasPreviousPage) { %></p>

<p>&lt;%= Ajax.ActionLink(&ldquo;Previous&rdquo;, Model.Action, Model.Controller, new { page = (Model.PageIndex &ndash; 1).ToString() }, Model.AjaxOptions)%></p>

<p>&lt;% } %></p>

<p>&lt;% if (Model.GetFirstPageToLink() != 1) { %>&hellip;&lt;% } %></p>

<p>&lt;%for (var page = Model.GetFirstPageToLink(); page &lt;= Model.GetLastPageToLink(); page++) {</p>

<pre><code>if (page == Model.PageIndex) { %&gt;
    &lt;%=page.ToString()%&gt;
&lt;% } else { %&gt;
</code></pre>

<p>&lt;%= Ajax.ActionLink(page.ToString(), Model.Action, Model.Controller, new { page = page.ToString() }, Model.AjaxOptions)%></p>

<p>&lt;% } if (page != Model.GetLastPageToLink()) { %> | &lt;% } } %></p>

<p>&lt;% if (Model.GetLastPageToLink() != Model.PageCount) { %>&hellip;&lt;% } %></p>

<p>&lt;% if (Model.HasNextPage) { %></p>

<p>&lt;%= Ajax.ActionLink(&ldquo;Next&rdquo;, Model.Action, Model.Controller, new { page = (Model.PageIndex + 1).ToString() }, Model.AjaxOptions)%></p>

<p>&lt;% } %></p>

<p>```</p>

<p>The big difference here is the way that the links are generated. The original control simply creates an anchor tag and passes in the url generated by the Model. The AJAX control uses AJAX.ActionLink() instead, so we can have the link support AJAX.</p>

<p>So knowing how the control looks, this is the Model for the AJAX control itself:</p>

<p>``` c#</p>

<p>public class AjaxPaginationViewData
{</p>

<pre><code>public int NumberOfPagesToEachSide { get; set; }
public int PageIndex { get; set; }
public int PageSize { get; set; }
public int TotalCount { get; set; }

public string Action { get; set; }
public string Controller { get; set; }

public AjaxOptions AjaxOptions { get; set; }

public int PageCount
{
    get
    {
        return (int)Math.Ceiling((double)TotalCount / PageSize);
    }
}
public bool HasPreviousPage
{
    get
    {
        return (PageIndex &gt; 1);
    }
}

public bool HasNextPage
{
    get
    {
        return (PageIndex * PageSize) &lt;= TotalCount;
    }
}

public int GetFirstPageToLink()
{
    return (PageIndex - NumberOfPagesToEachSide &gt; 1 ? PageIndex - NumberOfPagesToEachSide : 1);
}

public int GetLastPageToLink()
{
    return (PageIndex + NumberOfPagesToEachSide &lt; PageCount ? PageIndex + NumberOfPagesToEachSide : PageCount);
}
</code></pre>

<p>}</p>

<p>```</p>

<p>That pretty much explains how the control is built.</p>

<p>The only thing left is how the interaction with PagedList happens.  For that we look at the action that the control calls.  In this example, we’re calling SomeAction in SomeController, and it would look something like this:</p>

<p>``` c#</p>

<p>public ActionResult SomeAction(int page)
{</p>

<pre><code>CachedPage = page;
var query = GetSearchQuery(CachedSearchParameters);
var model = query.ToPagedList(page, DefaultPageSize);
return PartialView("AjaxResults", model);
</code></pre>

<p>}</p>

<p>```</p>

<p>The ToPagedList performs the functionality that is included with the PagedList classes which you can find <a href="http://pagedlist.codeplex.com/">here</a>.</p>

<p>Let me know what you think, and if you’d like some demo source to see this in action I can happily provide, just let me know.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Five Common SEO Mistakes]]></title>
    <link href="http://josephbulger.com/blog/2009/03/07/seo-mistakes/"/>
    <updated>2009-03-07T03:02:47-05:00</updated>
    <id>http://josephbulger.com/blog/2009/03/07/seo-mistakes</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve come across this many times when building sites for clients.  ASP.NET is really great for building dynamic content pages, but not so great when you&rsquo;re trying to expose those dynamic pages to a crawler or bot used by search engines.  Usually I&rsquo;ve found myself having to index the crawler or bot to go find specific pages if I wanted something to show up explicitly.  For instance, you might have a product that you really want to showcase and have searchable.  The product&rsquo;s URL, however might be parameter based, something like <a href="http://www.yourstore.com/productdetails.aspx?productid=5.">http://www.yourstore.com/productdetails.aspx?productid=5.</a></p>

<!-- more -->


<p>Here are 5 common mistakes you should avoid when building sites that need to be Search Engine Optimized (SEO).</p>

<h2><strong>1. Overuse of Button Controls</strong></h2>

<p>The Button and LinkButton controls are handy for running server-side logic when a link or push button is clicked, but keep in mind that <strong>search engines can&rsquo;t follow these links</strong>. These controls cause a postback via Javascript code that search engines are unable to execute.  I&rsquo;ve seen more than one developer who&rsquo;s standard method of linking from one page to another was to drag a LinkButton control onto the page and then place a Response.Redirect in the event handler, making the entire site completely uncrawlable by search engines.</p>

<p>It seems obvious, but when linking between pages try to use a plain text link or Hyperlink control whenever possible.</p>

<h2><strong>2. Duplicate Page Titles</strong></h2>

<p>With any dynamically generated site, it can be difficult to generate unique page titles for each and every page, but it really is important.  If you have a quality site, then the search engines are working hard to drive traffic to your site.  After all, that is their core business &ndash; to provide links to the best resources on whatever the searcher is looking for. </p>

<p>So you need to make it easy for the search engines to figure out exactly what your pages are about, and the page title is an important part of that.  Not only that, but once the search engine <em>does</em> rank your page highly, the title is the primary text that searchers will be seeing and using to determine whether to click on your listing or not!  </p>

<p>On dynamically generated pages, try to to use a keyword-rich page title, such as the full name of the product on a product page, for best results.  If you don&rsquo;t have any appropriate field, provide the ability for the user to specify their own page titles for each item being displayed.  It&rsquo;s worth their time and effort.</p>

<h2><strong>3. Duplicate Meta Descriptions</strong></h2>

<p>Much like the duplicate page title issue, the meta description tag should not be duplicated across your pages either.  Like the page title, this text is used (although to a lesser extent) by the search engines to determine the content of your page and also appears underneath your title in the search engine listing.  Depending on the number of pages of dynamic content on your site, it might not be practical to add multi-sentence descriptions for every single page.  In this case, simply remove the meta description tag altogether.  The major search engines are pretty good at improvising when the description tag is missing by displaying portions of the page body that match the user&rsquo;s search keywords instead.</p>

<p>In my experience, the SEO benefit of adding a keyword-rich meta description is not enough to warrant spending a great deal of time creating custom descriptions for sites with 100+ pages.</p>

<h2><strong>4. State-Dependent Pages</strong></h2>

<p>Search engines rely heavily on the idea that every unique page has it&rsquo;s own unique URL.  That means that if you are basing a page&rsquo;s content on session variables or viewstate parameters, you are probably going to have problems getting that content indexed.  Once a search engine finds a URL, Google will continue spidering that page, but you can bet that the search engine robot will not navigate through your site again to get there.  So you need to make sure that any content you want indexed by search engines can be accessed by simply opening your browser and typing in the URL of that content.  That means unique URLs for every product in your ecommerce store, ever category in your directory, etc. </p>

<p>My recommendation is to use viewstate rarely and session variables almost never.</p>

<h2><strong>5. Duplicate Content When Rewriting URLs With ASP.NET</strong></h2>

<p>When you rewrite a URL, the browser is displaying a keyword-rich URL, but internally the URL of the page being displayed is still the ugly URL with the querystring parameters.  In technical terms, the Request.RawURL value might be something like:</p>

<ol>
<li> <a href="http://www.store.com/products/coffee-cup.aspx">http://www.store.com/products/coffee-cup.aspx</a></li>
</ol>


<p>but the Request.Url value would still be something like:</p>

<ol>
<li> <a href="http://www.store.com/products.aspx?productID=15%C2%A0%C2%A0">http://www.store.com/products.aspx?productID=15%C2%A0%C2%A0</a></li>
</ol>


<p>All of that is just fine, but a problem can arise if you have a Button or LinkButton control that posts back on that page.  <strong><em>By default, the button control will post back to the Request.URL value</em></strong>. causing the URL to change after postback.  This can be a problem if some users end up linking to your &lsquo;ugly&rsquo; URLs, because the search engines will find that link and spider it.  To the search engine the two different URLs signify two different pages and both will be indexed seperately, causing a pretty ugly duplicate content problem.  </p>

<p>Thankfully, starting with .NET 2.0, there is a <a href="http://msdn.microsoft.com/en-us/library/system.web.ui.webcontrols.button.postbackurl%28VS.80%29.aspx">PostBackUrl</a> property on the button controls.  Set this property to the Request.RawUrl value and your button will postback to the &lsquo;pretty&rsquo; URL.</p>

<p> The original article that I read this from was on this <a href="http://www.dexign.net/post/2008/07/08/Five-ASPNET-SEO-Mistakes.aspx">blog</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Visual Studio Tip: Jump Between Braces]]></title>
    <link href="http://josephbulger.com/blog/2009/03/07/visual-studio-jump-tip/"/>
    <updated>2009-03-07T03:01:32-05:00</updated>
    <id>http://josephbulger.com/blog/2009/03/07/visual-studio-jump-tip</id>
    <content type="html"><![CDATA[<p>Have you ever found yourself lost inside some sort of block statement, wondering when the beginning of the block began or ended?  I just found this awesome feature in Visual Studio that allows me to jump to the beginning or ending of a block. </p>

<!-- more -->


<p>To do this, put your cursor before or after the brace (your choice) and then press <strong>Ctrl+]</strong>. It works with either curly or round braces.</p>

<p>I originally found this nifty little feature from another <a href="http://vkreynin.wordpress.com/2008/07/09/jump-between-braces-in-visual-studio/">blog</a></p>
]]></content>
  </entry>
  
</feed>
