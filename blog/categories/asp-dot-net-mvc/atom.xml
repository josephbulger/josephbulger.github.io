<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: asp.net Mvc | Joseph Bulger]]></title>
  <link href="http://josephbulger.github.io/blog/categories/asp-dot-net-mvc/atom.xml" rel="self"/>
  <link href="http://josephbulger.github.io/"/>
  <updated>2014-02-09T18:57:42-05:00</updated>
  <id>http://josephbulger.github.io/</id>
  <author>
    <name><![CDATA[Joseph Bulger]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ASP.NET MVC Model Binding: The Ins and Outs]]></title>
    <link href="http://josephbulger.github.io/blog/2011/08/22/asp-net-mvc-model-binding-the-ins-and-outs/"/>
    <updated>2011-08-22T08:00:18-04:00</updated>
    <id>http://josephbulger.github.io/blog/2011/08/22/asp-net-mvc-model-binding-the-ins-and-outs</id>
    <content type="html"><![CDATA[<p>Model Binding can be a tricky thing to get right with MVC. Dealing with flat POCOs works fine, but when you start getting into more complex, truly object oriented domain objects, things get out of hand pretty quickly.</p>

<!-- more -->


<p>Let&rsquo;s say you have a package class like this:</p>

<p><div><script src='https://gist.github.com/1154718.js?file=Model.cs'></script>
<noscript><pre><code>namespace ModelBinding.Models
{
    public class Package
    {
        public string Street { get; set; }
        public string City { get; set; }
        public string State { get; set; }
        public int Zip { get; set; }
    }
}</code></pre></noscript></div>
</p>

<p>The Package is basically flat at this point. Wiring this up with Model Binding in MVC is trivial. Just create your controller to handle the class when an action get&rsquo;s posted like:</p>

<p><div><script src='https://gist.github.com/1154718.js?file=Controller.cs'></script>
<noscript><pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.Mvc;
using ModelBinding.Models;

namespace ModelBinding.Controllers
{
    public class HomeController : Controller
    {
        public ActionResult Index()
        {
            ViewBag.Message = &quot;Welcome to ASP.NET MVC!&quot;;

            return View(new Package());
        }

        [HttpPost]
        public ActionResult Index(Package model)
        {
            return Json(model);
        }
    }
}</code></pre></noscript></div>
</p>

<p>and make a view that uses the class as it&rsquo;s model:</p>

<p><div><script src='https://gist.github.com/1154718.js?file=View'></script>
<noscript><pre><code>@model ModelBinding.Models.Package
           
@{
    ViewBag.Title = &quot;Home Page&quot;;
}

&lt;h2&gt;@ViewBag.Message&lt;/h2&gt;

@using (Html.BeginForm(&quot;Index&quot;, &quot;Home&quot;))
{
    @Html.EditorForModel()
    
    &lt;input type=&quot;submit&quot; value=&quot;lets do this&quot; /&gt;
}</code></pre></noscript></div>
</p>

<p>This code works fine. The problem is I don&rsquo;t like the code! My package class is all wrong. All those properties should be inside an Address Class, which is <strong>used by </strong>the Package.</p>

<p>Once you make a more complicated model than a flat one, everything starts breaking. The problem is that so many things break you have to go through and fix all the pieces one at a time, so we&rsquo;ll have to go through each of these issues in a post by themselves.</p>

<p>The first thing we&rsquo;re going to address is this: when you change the Package to have an Address, the View shows <strong>nothing</strong> on a GET. What happened to the View? We&rsquo;ll cover that next.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Creating an PagedList<T> That Uses AJAX]]></title>
    <link href="http://josephbulger.github.io/blog/2010/04/14/creating-an-pagedlistt-that-uses-ajax/"/>
    <updated>2010-04-14T05:05:58-04:00</updated>
    <id>http://josephbulger.github.io/blog/2010/04/14/creating-an-pagedlistt-that-uses-ajax</id>
    <content type="html"><![CDATA[<p>I’ve been using this PagedList functionality that i found from a <a href="http://blog.wekeroad.com/2007/12/10/aspnet-mvc-pagedlistt/">blog article Rob Conery</a> put up, and <a href="http://code-inside.de/blog-in/2008/04/08/aspnet-mvc-pagination-view-user-control/">a control I found by Robert Muehsig</a> which I’ve really enjoyed using so far.</p>

<p>One of the things that was missing from the functional set that I ended up needing was the ability to page the list, but through issuing AJAX requests instead of the typical post back.</p>

<p>So I went off and extended the existing model to support AJAX requests, and thought I would share it in case anyone else needed to do the same thing.<!-- more --></p>

<p>I guess the best place to start would be the use case.  So to start I created a control that encapsulates the Paging UI layout and calls I need.  The use of the original control looks like this:</p>

<p>``` c#</p>

<p>Html.RenderPartial(&ldquo;AjaxPagination&rdquo;,</p>

<pre><code>new AjaxPaginationViewData
    {
        PageIndex = Model.PageIndex,
        Action = "CondoPage",
        Controller = "Home",
        AjaxOptions =
            new AjaxOptions { 
                UpdateTargetId = "updatedContent" },
        TotalCount = Model.TotalCount,
        PageSize = Model.PageSize,
        NumberOfPagesToEachSide = 2
    }
</code></pre>

<p>);</p>

<p>```</p>

<p>The new AJAX functionality is called similarly:</p>

<p>``` c#</p>

<p>&lt;% using (Ajax.BeginForm(&ldquo;SomePage&rdquo;,</p>

<pre><code>    "SomeController",
    new AjaxOptions { UpdateTargetId = "updatedContent" })) { %&gt;

    &lt;% Html.RenderPartial("AjaxPagination",
        new AjaxPaginationViewData {
                PageIndex = Model.PageIndex,
                Action = "SomeAction",
                Controller = "SomeController",
                AjaxOptions = new AjaxOptions
                    { UpdateTargetId = "updatedContent" },
                TotalCount = Model.TotalCount,
                PageSize = Model.PageSize,
                NumberOfPagesToEachSide = 2
    });%&gt;
</code></pre>

<p>&lt;% } %></p>

<p>```</p>

<p>A couple things to note. You’ll notice that the AJAX control is rendered inside a Ajax.BeginForm. This is because I’m using the Microsoft.Ajax way of making AJAX calls.  This could also be done using jQuery or something else that can process AJAX calls. I just went this way because the scripts are already included in asp.net mvc app when you first create the project.  The result of the AJAX call will be a partial view, and we’ll need to put that somewhere.  That’s where the UpdatedTargetId comes into play. Other things we include in the AJAX control that are not in the original are the Action and the Controller, and some AjaxOptions. PageActionLink doesn’t work with the AJAX control, because we’ll be using Ajax.ActionLink to build the link, which is why I broke it up into Action, and Controller. For the AjaxOptions, we need those to specify the target of the call.</p>

<p>So now that’s been explained, let’s look at the controls themselves.  Here’s a comparison of the original control and the ajax control.</p>

<p>The original is one this way:</p>

<p>``` c#</p>

<p>&lt;% if (Model.HasPreviousPage) { %></p>

<pre><code>&lt;a href="&lt;%=Model.PageActionLink.Replace("%7Bpage%7D", (Model.PageIndex - 1).ToString())%&gt;"&gt;Previous&lt;/a&gt;
</code></pre>

<p>&lt;% } %></p>

<p>&lt;% if (Model.GetFirstPageToLink() != 1) { %>&hellip;&lt;% } %></p>

<p>&lt;%for (var page = Model.GetFirstPageToLink(); page &lt;= Model.GetLastPageToLink(); page++) {</p>

<pre><code>if (page == Model.PageIndex) { %&gt;
    &lt;%=page.ToString()%&gt;
</code></pre>

<p>&lt;% } else { %></p>

<pre><code>&lt;a href="&lt;%=Model.PageActionLink.Replace("%7Bpage%7D", page.ToString())%&gt;"&gt;&lt;%=page.ToString()%&gt;&lt;/a&gt;
</code></pre>

<p>&lt;% }</p>

<pre><code>if (page != Model.GetLastPageToLink()) { %&gt;|&lt;% } } %&gt;
</code></pre>

<p>&lt;% if (Model.GetLastPageToLink() != Model.PageCount) { %>&hellip;&lt;% } %></p>

<p>&lt;% if (Model.HasNextPage) { %></p>

<pre><code>&lt;a href="&lt;%=Model.PageActionLink.Replace("%7Bpage%7D", (Model.PageIndex + 1).ToString())%&gt;"&gt;Next&lt;/a&gt;
</code></pre>

<p>&lt;% } %></p>

<p>```</p>

<p>And the AJAX control is done this way:</p>

<p>``` c#</p>

<p>&lt;% if (Model.HasPreviousPage) { %></p>

<p>&lt;%= Ajax.ActionLink(&ldquo;Previous&rdquo;, Model.Action, Model.Controller, new { page = (Model.PageIndex &ndash; 1).ToString() }, Model.AjaxOptions)%></p>

<p>&lt;% } %></p>

<p>&lt;% if (Model.GetFirstPageToLink() != 1) { %>&hellip;&lt;% } %></p>

<p>&lt;%for (var page = Model.GetFirstPageToLink(); page &lt;= Model.GetLastPageToLink(); page++) {</p>

<pre><code>if (page == Model.PageIndex) { %&gt;
    &lt;%=page.ToString()%&gt;
&lt;% } else { %&gt;
</code></pre>

<p>&lt;%= Ajax.ActionLink(page.ToString(), Model.Action, Model.Controller, new { page = page.ToString() }, Model.AjaxOptions)%></p>

<p>&lt;% } if (page != Model.GetLastPageToLink()) { %> | &lt;% } } %></p>

<p>&lt;% if (Model.GetLastPageToLink() != Model.PageCount) { %>&hellip;&lt;% } %></p>

<p>&lt;% if (Model.HasNextPage) { %></p>

<p>&lt;%= Ajax.ActionLink(&ldquo;Next&rdquo;, Model.Action, Model.Controller, new { page = (Model.PageIndex + 1).ToString() }, Model.AjaxOptions)%></p>

<p>&lt;% } %></p>

<p>```</p>

<p>The big difference here is the way that the links are generated. The original control simply creates an anchor tag and passes in the url generated by the Model. The AJAX control uses AJAX.ActionLink() instead, so we can have the link support AJAX.</p>

<p>So knowing how the control looks, this is the Model for the AJAX control itself:</p>

<p>``` c#</p>

<p>public class AjaxPaginationViewData
{</p>

<pre><code>public int NumberOfPagesToEachSide { get; set; }
public int PageIndex { get; set; }
public int PageSize { get; set; }
public int TotalCount { get; set; }

public string Action { get; set; }
public string Controller { get; set; }

public AjaxOptions AjaxOptions { get; set; }

public int PageCount
{
    get
    {
        return (int)Math.Ceiling((double)TotalCount / PageSize);
    }
}
public bool HasPreviousPage
{
    get
    {
        return (PageIndex &gt; 1);
    }
}

public bool HasNextPage
{
    get
    {
        return (PageIndex * PageSize) &lt;= TotalCount;
    }
}

public int GetFirstPageToLink()
{
    return (PageIndex - NumberOfPagesToEachSide &gt; 1 ? PageIndex - NumberOfPagesToEachSide : 1);
}

public int GetLastPageToLink()
{
    return (PageIndex + NumberOfPagesToEachSide &lt; PageCount ? PageIndex + NumberOfPagesToEachSide : PageCount);
}
</code></pre>

<p>}</p>

<p>```</p>

<p>That pretty much explains how the control is built.</p>

<p>The only thing left is how the interaction with PagedList happens.  For that we look at the action that the control calls.  In this example, we’re calling SomeAction in SomeController, and it would look something like this:</p>

<p>``` c#</p>

<p>public ActionResult SomeAction(int page)
{</p>

<pre><code>CachedPage = page;
var query = GetSearchQuery(CachedSearchParameters);
var model = query.ToPagedList(page, DefaultPageSize);
return PartialView("AjaxResults", model);
</code></pre>

<p>}</p>

<p>```</p>

<p>The ToPagedList performs the functionality that is included with the PagedList classes which you can find <a href="http://pagedlist.codeplex.com/">here</a>.</p>

<p>Let me know what you think, and if you’d like some demo source to see this in action I can happily provide, just let me know.</p>
]]></content>
  </entry>
  
</feed>
