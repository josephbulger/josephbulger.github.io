<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Dependency Inversion Principle | Joseph Bulger]]></title>
  <link href="http://josephbulger.com/blog/categories/dependency-inversion-principle/atom.xml" rel="self"/>
  <link href="http://josephbulger.com/"/>
  <updated>2014-08-24T20:46:43-04:00</updated>
  <id>http://josephbulger.com/</id>
  <author>
    <name><![CDATA[Joseph Bulger]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SOLID Principles: Dependency Inversion Principle]]></title>
    <link href="http://josephbulger.com/blog/2011/09/14/solid-principles-dependency-inversion-principle/"/>
    <updated>2011-09-14T14:00:18-04:00</updated>
    <id>http://josephbulger.com/blog/2011/09/14/solid-principles-dependency-inversion-principle</id>
    <content type="html"><![CDATA[<p><a href="http://en.wikipedia.org/wiki/Dependency_inversion_principle">Dependency Inversion Principle</a> has a dramatic effect on your code base. It has the potential to decouple your code in ways that you never would have thought possible before. Using a good IoC container can make all the difference as well.</p>

<!-- more -->


<p>The best way to explain this principle would probably be an example.
Let&rsquo;s say you have a car like this</p>

<p>{% gist 1208366 CoupledCar.cs %}</p>

<p>Notice the engine that belongs to the car. First of all, the car is actually creating the engine. This means that the car is tightly coupled to the engine it&rsquo;s creating. Secondly, this creates a concrete coupling on the car to a specific kind of engine, the FourCylinderEngine.</p>

<p>A better solution would be to use Dependency Inversion. You should depend on an interface instead of a concrete class. Back in our example, our FoudCyclinderEngine looks like this</p>

<p>{% gist 1208366 FourCylinderEngine.cs %}</p>

<p>Notice how it implements Engine. That&rsquo;s the interface our Car should be using. There&rsquo;s one additional problem, though. Right now the Car is creating it&rsquo;s Engine, but you can&rsquo;t instantiate an interface, so what do you do? That&rsquo;s the key to Dependency Inversion. You&rsquo;re saying,</p>

<blockquote><p>a Car does not depend on knowing about how to create an Engine</p></blockquote>

<p>It just <em>uses</em> it. So the new Car class looks like this</p>

<p>{% gist 1208366 DecoupledCar.cs %}</p>

<p>So how does the engine get created? Obviously something is passing in the engine to the Car, but what? You need a new class. Maybe a CarManufacturer or something, which is responsible for manufacturing cars. Part of that responsibility would be putting an engine in a car.</p>

<p>Want more info? <a href="http://www.dimecasts.net/Content/WatchEpisode/96">Check out this dime cast</a>.</p>
]]></content>
  </entry>
  
</feed>
