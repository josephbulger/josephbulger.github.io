---
author: joseph
comments: false
date: 2009-6-03 09:31:21
layout: post
slug: c-had-it-right-multiple-inheritance-rocks-single-inheritance-not-so-much
title: C++ had it right, Multiple Inheritance Rocks, Single Inheritance... not so
  much.
wordpress_id: 60
categories: [c#, contracts, inheritance, java]
---

I've been having a lot of problems with my coding lately. I primarily program in C#, but I originally came from a C++ world. When I first learned Java, and was introduced to the idea of Single Inheritance, the sales pitch made a lot of sense to me. How can any class really derive from multiple classes? I drank the kool-aid, and I’ve been living in a Single Inheritance world ever since. <!-- more -->

Now, the caveat to all of this was that you had this thing called an interface that actually allowed you to define declarations of behavior that could later be implemented. This could be done any number of times. This also made a lot of sense, and they would do some simplistic model that illustrates the concept. I imagine for purposes of this article we should probably illustrate something as well just to drive home the point. Let’s say you have a Coin. A Coin is a kind of Currency. So the simple inheritance chain would dictate that Coin inherits from Currency, and everything is fine. Of course, in order for this to matter at all, there needs to be some benefit to having Coin inherit from Currency. So let’s say that Currency has some behavior called CalculateBuyingPower that actually figures out what kind of buying power that particular Currency has. Ok, so now we have an inheritance chain, and we have a direct benefit, figuring out the buying power of the Coin.

If that’s as far as you take it, then everything’s all fine and dandy, and Single Inheritance is great. The problem is, that in the Real World, what we call Objects can legitimately “be” multiple things. This is equally true in the Software World. So, going back to the Coin, not only is the Coin a Currency, but the Coin is also a MetalConstruct. A MetalConstruct is just my way of saying something that is made of metal. Why do I care? Simple. At some point during the life of a Coin, it is entirely possible that the buying power of the Coin will reach a point that it would actually be better to melt down the Coin because the value of the Metal in the coin is much higher (look at what a penny is made of nowadays and you’ll see what I mean). Now, a lot of you are going to say, “That’s fine, just define a MetalConstruct interface and you should be good to go.” In a lot of cases that might be true, but in this example we fine a very big problem. The point of the MetalConstruct is to normalize the behavior of melting down the Coin. No matter what kind of MetalConstruct you have, the melting process for it is always going to be the same. Sure there are variations in melting temperature and what not, but the overall process is the same. The point being, that an interface can only declare that behavior MeltDown should exist, but not define the implementation of it. This is the problem with Single Inheritance. I now need a way for the Coin to be both a Currency and MetalConstruct, which provides the Coin with behaviors CalculateBuyingPower and MeltDown. Coin shouldn’t have to define how to do either of those behaviors, because that’s not it’s [responsibility](http://en.wikipedia.org/wiki/Single_responsibility_principle).

During software development, when you’re working on defining your domain, this can come up quite often, actually. With the advent of extension methods in .NET, you’re able to ease the pain a bit in C#, but the fundamental problem is really still there. What I would like to see would be one of two things. It would be nice if you could inherit from multiple abstract classes, which would allow you to define Contracts at the abstract class level. Another idea would be to bring forward the construct of a contract as a [first-class citizen](http://en.wikipedia.org/wiki/First-class_citizen), it would be similar to an abstract class and an interface in the sense that you could not create one directly, but would allow for definition of behavior while still being able to have a class implement numerous contracts. It would be a totally new way of defining an object, apart from class, struct, or interface entirely perhaps.

So now I’m looking back at C++ and I’m thinking it would be really nice if I had Multiple Inheritance so I can just get past this ridiculous wall I’m having to climb. Possibly with .NET 4.0, Microsoft is bringing forth the idea of Code Contracts , which might help when you’re trying to get around Single Inheritance issues when dealing with [Design by Contract](http://en.wikipedia.org/wiki/Design_by_Contract), but for real domain model issues, I think the problem still remains.

Food for thought.
